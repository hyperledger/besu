/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

apply plugin: 'java-library'

jar {
  archiveBaseName = calculateArtifactId(project)
  manifest {
    attributes(
      'Specification-Title': archiveBaseName,
      'Specification-Version': project.version,
      'Implementation-Title': archiveBaseName,
      'Implementation-Version': calculateVersion(),
      'Commit-Hash': getGitCommitDetails(40).hash
      )
  }
}

def blockchainReferenceTests = tasks.register("blockchainReferenceTests")  {
  final referenceTestsPath = 'src/reference-test/external-resources/BlockchainTests'
  final generatedTestsPath = "$buildDir/generated/sources/reference-test/$name/java"
  inputs.files fileTree(referenceTestsPath),
    fileTree(generatedTestsPath)
  outputs.files generatedTestsPath
  generateTestFiles(
    fileTree(referenceTestsPath),
    file("src/reference-test/templates/BlockchainReferenceTest.java.template"),
    "BlockchainTests",
    "$generatedTestsPath/org/hyperledger/besu/ethereum/vm/blockchain",
    "BlockchainReferenceTest",
    "org.hyperledger.besu.ethereum.vm.blockchain",
    ("BlockchainTests/InvalidBlocks/bcExpectSection") // exclude test for test filling tool
    )
}

def eipBlockchainReferenceTests = tasks.register("eipBlockchainReferenceTests")  {
  final referenceTestsPath = 'src/reference-test/external-resources/EIPTests/BlockchainTests'
  final generatedTestsPath = "$buildDir/generated/sources/reference-test/$name/java"
  inputs.files fileTree(referenceTestsPath),
    fileTree(generatedTestsPath)
  outputs.files generatedTestsPath
  generateTestFiles(
    fileTree(referenceTestsPath),
    file("src/reference-test/templates/BlockchainReferenceTest.java.template"),
    "EIPTests${File.separatorChar}BlockchainTests",
    "$generatedTestsPath/org/hyperledger/besu/ethereum/vm/eip",
    "EIPBlockchainReferenceTest",
    "org.hyperledger.besu.ethereum.vm.eip",
    "EIPTests${File.separatorChar}BlockchainTests${File.separatorChar}StateTests${File.separatorChar}stEOF" // exclude EOF tests
    )
}

def eipStateReferenceTests = tasks.register("eipStateReferenceTests")  {
  final referenceTestsPath = 'src/reference-test/external-resources/EIPTests/StateTests'
  final generatedTestsPath = "$buildDir/generated/sources/reference-test/$name/java"
  inputs.files fileTree(referenceTestsPath),
    fileTree(generatedTestsPath)
  outputs.files generatedTestsPath
  generateTestFiles(
    fileTree(referenceTestsPath),
    file("src/reference-test/templates/GeneralStateReferenceTest.java.template"),
    "EIPTests${File.separatorChar}StateTests",
    "$generatedTestsPath/org/hyperledger/besu/ethereum/vm/eip",
    "EIPStateReferenceTest",
    "org.hyperledger.besu.ethereum.vm.eip",
    "EIPTests${File.separatorChar}StateTests${File.separatorChar}stEOF" // exclude EOF tests
    )
}

def extractStableFixtures = tasks.register("extractStableFixtures", Copy) {
  from {
    tarTree(configurations.tarConfig.files.find { it.name.startsWith('execution-spec-tests') })
  }
  into layout.buildDirectory.dir("execution-spec-tests")
}

def executionSpecTests = tasks.register("executionSpecTests") {
  dependsOn extractStableFixtures
  final referenceTestsDir = layout.buildDirectory.dir("execution-spec-tests")
  final generatedTestsDir = layout.buildDirectory.dir("generated/sources/reference-test/$name/java")

  inputs.files fileTree(referenceTestsDir), fileTree(generatedTestsDir)
  outputs.files generatedTestsDir
  // generate blockchain_tests grouped by hardfork/EIP:
  generateTestFilesGroupedByDirectory(
    fileTree(referenceTestsDir.get().dir("fixtures/blockchain_tests")),
    file("src/reference-test/templates/BlockchainReferenceTest.java.template"),
    "fixtures",
    "blockchain_tests",
    generatedTestsDir.get().dir("org/hyperledger/besu/ethereum/vm/executionspec").asFile.path,
    "ExecutionSpecBlockchainTest",
    "org.hyperledger.besu.ethereum.vm.executionspec",
    )

  // generate state_tests grouped by hardfork/EIP:
  generateTestFilesGroupedByDirectory(
    fileTree(referenceTestsDir.get().dir("fixtures/state_tests")),
    file("src/reference-test/templates/GeneralStateReferenceTest.java.template"),
    "fixtures",
    "state_tests",
    generatedTestsDir.get().dir("org/hyperledger/besu/ethereum/vm/executionspec").asFile.path,
    "ExecutionSpecStateTest",
    "org.hyperledger.besu.ethereum.vm.executionspec",
    )
}

def extractDevnetFixtures = tasks.register("extractDevnetFixtures", Copy) {
  from {
    tarTree(configurations.devnetTarConfig.files.find { it.name.startsWith('execution-spec-tests') })
  }
  into layout.buildDirectory.dir("execution-spec-devnet-tests")
}

def executionSpecDevnetTests = tasks.register("executionSpecDevnetTests") {
  dependsOn extractDevnetFixtures
  final referenceTestsDir = layout.buildDirectory.dir("execution-spec-devnet-tests")
  final generatedTestsDir = layout.buildDirectory.dir("generated/sources/reference-test/$name/java")

  inputs.files fileTree(referenceTestsDir), fileTree(generatedTestsDir)
  outputs.files generatedTestsDir

  generateTestFilesGroupedByDirectory(
    fileTree(referenceTestsDir.get().dir("fixtures/blockchain_tests")),
    file("src/reference-test/templates/BlockchainReferenceTest.java.template"),
    "fixtures",
    "blockchain_tests",
    generatedTestsDir.get().dir("org/hyperledger/besu/ethereum/vm/executionspecdevnet").asFile.path,
    "ExecutionSpecDevnetBlockchainTest",
    "org.hyperledger.besu.ethereum.vm.executionspecdevnet",
    )

  generateTestFilesGroupedByDirectory(
    fileTree(referenceTestsDir.get().dir("fixtures/state_tests")),
    file("src/reference-test/templates/GeneralStateReferenceTest.java.template"),
    "fixtures",
    "state_tests",
    generatedTestsDir.get().dir("org/hyperledger/besu/ethereum/vm/executionspecdevnet").asFile.path,
    "ExecutionSpecDevnetStateTest",
    "org.hyperledger.besu.ethereum.vm.executionspecdevnet",
    )
}

def generalstateReferenceTests = tasks.register("generalstateReferenceTests")  {
  final referenceTestsPath = "src/reference-test/external-resources/GeneralStateTests"
  final generatedTestsPath = "$buildDir/generated/sources/reference-test/$name/java"
  inputs.files fileTree(referenceTestsPath),
    fileTree(generatedTestsPath)
  outputs.files generatedTestsPath
  generateTestFiles(
    fileTree(referenceTestsPath),
    file("src/reference-test/templates/GeneralStateReferenceTest.java.template"),
    "GeneralStateTests",
    "$generatedTestsPath/org/hyperledger/besu/ethereum/vm/generalstate",
    "GeneralStateReferenceTest",
    "org.hyperledger.besu.ethereum.vm.generalstate",
    )
}

def generalstateRegressionReferenceTests = tasks.register("generalstateRegressionReferenceTests") {
  final referenceTestsPath = "src/reference-test/resources/regressions/generalstate"
  final generatedTestsPath = "$buildDir/generated/sources/reference-test/$name/java"
  inputs.files fileTree(referenceTestsPath),
    fileTree(generatedTestsPath)
  outputs.files generatedTestsPath
  generateTestFiles(
    fileTree(referenceTestsPath),
    file("src/reference-test/templates/GeneralStateReferenceTest.java.template"),
    "regressions",
    "$generatedTestsPath/org/hyperledger/besu/ethereum/vm/generalstate",
    "GeneralStateRegressionReferenceTest",
    "org.hyperledger.besu.ethereum.vm.generalstate"
    )
}

sourceSets {
  referenceTest {
    java {
      compileClasspath += main.output
      runtimeClasspath += main.output
      srcDirs "src/reference-test/java",
        blockchainReferenceTests,
        eipBlockchainReferenceTests,
        eipStateReferenceTests,
        executionSpecTests,
        executionSpecDevnetTests,
        generalstateReferenceTests,
        generalstateRegressionReferenceTests
    }
    resources {
      srcDirs 'src/reference-test/resources',
        'src/reference-test/external-resources',
        'src/reference-test/templates',
        'build/execution-spec-tests/',
        'build/execution-spec-devnet-tests/'
    }
  }
}

// Both stable and devnet execution-spec-tests tarballs contain fixtures/.meta/index.json
tasks.named('processReferenceTestResources') {
  dependsOn extractStableFixtures, extractDevnetFixtures
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

configurations {
  referenceTestAnnotationProcessor.extendsFrom testAnnotationProcessor
  // we need this because referenceTestImplementation defaults to 'canBeResolved=false'.
  tarConfig.extendsFrom referenceTestImplementation
  tarConfig {
    canBeResolved = true
    canBeConsumed = false
  }
  devnetTarConfig {
    canBeResolved = true
    canBeConsumed = false
  }
}

dependencies {
  implementation project(':config')
  implementation project(':crypto:algorithms')
  implementation project(':datatypes')
  implementation project(':ethereum:core')
  implementation project(':ethereum:eth')
  implementation project(':ethereum:blockcreation')
  implementation project(':consensus:merge')
  implementation project(':metrics:core')
  implementation project(':util')
  implementation project(path: ':ethereum:core', configuration: 'testSupportArtifacts')
  implementation project(':ethereum:rlp')
  implementation project(':evm')
  implementation project(':services:kvstore')

  implementation 'io.consensys.tuweni:tuweni-rlp'
  implementation 'com.fasterxml.jackson.core:jackson-databind'
  implementation 'com.google.guava:guava'
  implementation 'com.google.dagger:dagger'
  annotationProcessor 'com.google.dagger:dagger-compiler'

  referenceTestImplementation project(path: ':config')
  referenceTestImplementation project(path: ':datatypes')
  referenceTestImplementation project(path: ':ethereum:core')
  referenceTestImplementation project(path: ':ethereum:eth')
  referenceTestImplementation project(path: ':ethereum:blockcreation')
  referenceTestImplementation project(path: ':consensus:merge')
  referenceTestImplementation project(path: ':metrics:core')
  referenceTestImplementation project(path: ':ethereum:core', configuration: 'testSupportArtifacts')
  referenceTestImplementation project(path: ':ethereum:rlp')
  referenceTestImplementation project(path: ':ethereum:rlp', configuration: 'testSupportArtifacts')
  referenceTestImplementation project(path: ':ethereum:trie')
  referenceTestImplementation project(path: ':evm')
  referenceTestImplementation project(path: ':plugin-api')
  referenceTestImplementation project(path: ':testutil')
  referenceTestImplementation project(path: ':util')
  // the following will be resolved via custom ivy repository declared in root build.gradle
  referenceTestImplementation(
    group: 'ethereum', name: 'execution-spec-tests',
    version: 'v5.3.0', classifier: 'fixtures_develop', ext: 'tar.gz'
    )
  devnetTarConfig(
    group: 'ethereum', name: 'execution-spec-tests',
    version: 'bal@v4.0.0', classifier: 'fixtures_bal', ext: 'tar.gz'
    )
  referenceTestImplementation 'com.fasterxml.jackson.core:jackson-databind'
  referenceTestImplementation 'com.google.guava:guava'
  referenceTestImplementation 'io.consensys.tuweni:tuweni-bytes'
  referenceTestImplementation 'io.consensys.tuweni:tuweni-units'
  referenceTestImplementation 'org.assertj:assertj-core'
  referenceTestImplementation 'org.junit.jupiter:junit-jupiter-api'
  referenceTestImplementation 'org.junit.jupiter:junit-jupiter-params'

  referenceTestRuntimeOnly 'org.junit.jupiter:junit-jupiter'
}

tasks.register('referenceTests', Test) {
  useJUnitPlatform()
  doFirst {
    if (!file("src/reference-test/external-resources/README.md").exists()) {
      throw new GradleException("ethereum/referencetest/src/reference-test/external-resources/README.md missing: please clone submodules (git submodule update --init --recursive)")
    }
  }
  description = 'Runs ETH reference tests.'
  testClassesDirs = sourceSets.referenceTest.output.classesDirs
  classpath = sourceSets.referenceTest.runtimeClasspath
  filter {
    excludeTestsMatching "org.hyperledger.besu.ethereum.vm.executionspecdevnet.*"
  }
}

tasks.register('referenceTestsDevnet', Test) {
  useJUnitPlatform()
  description = 'Runs execution-spec-tests pre-release (devnet) reference tests.'
  testClassesDirs = sourceSets.referenceTest.output.classesDirs
  classpath = sourceSets.referenceTest.runtimeClasspath
  filter {
    includeTestsMatching "org.hyperledger.besu.ethereum.vm.executionspecdevnet.*"
  }
}

tasks.register('validateReferenceTestSubmodule') {
  description = "Checks that the reference tests submodule is not accidentally changed"
  doLast {
    def result = new ByteArrayOutputStream()
    def expectedHash = '9201075490807f58811078e9bb5ec895b4ac01a5'
    def submodulePath = java.nio.file.Path.of("${rootProject.projectDir}", "ethereum/referencetests/src/reference-test/external-resources").toAbsolutePath()
    try {
      exec {
        commandLine 'git', 'submodule', 'status', submodulePath
        standardOutput = result
        errorOutput = result
      }
    } catch (Exception ignore) {
      // Ignore it.  We want to fail in a friendly fashion if they don't have git installed.
      // The CI servers have git and that is the only critical place for this failure
      expectedHash = ''
    }

    if (!result.toString().contains(expectedHash)) {
      throw new GradleException("""For the Ethereum Reference Tests the git commit did not match what was expected.
  
If this is a deliberate change where you are updating the reference tests 
then update "expectedHash" in `ethereum/referencetests/build.gradle` as the 
commit hash for this task.
Expected hash   :  ${expectedHash}
Full git output : ${result}

If this is accidental you can correct the reference test versions with the 
following commands:
    pushd ${submodulePath}
    git fetch
    git checkout ${expectedHash}
    cd ..
    git add ${submodulePath}
    popd""")
    }
  }
}
processResources.dependsOn('validateReferenceTestSubmodule')

def generateTestFiles(
  FileTree jsonPath,
  File templateFile,
  String pathstrip,
  String destination,
  String namePrefix,
  String packageString,
  String ... excludedPath) {
  mkdir(destination)
  def referenceTestTemplate = templateFile.text

  def paths = []
  jsonPath.getFiles().forEach { testJsonFile ->
    def parentFile = testJsonFile.getParentFile()
    def parentPathFile = parentFile.getPath().substring(parentFile.getPath().indexOf(pathstrip))
    def isExcluded = excludedPath.any { excluded -> parentPathFile.startsWith(excluded) }
    if (!testJsonFile.getName().toString().startsWith(".") && !isExcluded) {
      def pathFile = testJsonFile.getPath()
      paths << pathFile.substring(pathFile.indexOf(pathstrip))
    }
  }

  paths.collate(5).eachWithIndex { tests, idx ->
    def testFile = file(destination + "/" + namePrefix + "_" + idx + ".java")

    def allPaths = '"' + tests.join('",\n        "') + '"'

    def testFileContents = referenceTestTemplate
      .replaceAll("%%TESTS_FILE%%", allPaths)
      .replaceAll("%%TESTS_NAME%%", namePrefix + "_" + idx)
      .replaceAll("%%PACKAGE_NAME%%", packageString)
    testFile.newWriter().withWriter { w -> w << testFileContents }
  }
}

def generateTestFilesGroupedByDirectory(
  FileTree jsonPath,
  File templateFile,
  String pathstrip,
  String groupBaseDir,
  String destination,
  String namePrefix,
  String packageString,
  String ... excludedPath) {
  mkdir(destination)
  def referenceTestTemplate = templateFile.text

  // Collect paths and group by hardfork/EIP directory
  def groups = [:] as TreeMap // sorted for deterministic output

  jsonPath.getFiles().forEach { testJsonFile ->
    def parentFile = testJsonFile.getParentFile()
    def parentPathFile = parentFile.getPath().substring(parentFile.getPath().indexOf(pathstrip))
    def isExcluded = excludedPath.any { excluded -> parentPathFile.startsWith(excluded) }
    if (!testJsonFile.getName().toString().startsWith(".") && !isExcluded) {
      def pathFile = testJsonFile.getPath()
      def relativePath = pathFile.substring(pathFile.indexOf(pathstrip))

      // Extract the part after groupBaseDir to get hardfork/eip/file structure
      def groupBaseDirIndex = relativePath.indexOf(groupBaseDir)
      def afterGroupBase = relativePath.substring(groupBaseDirIndex + groupBaseDir.length() + 1)
      def parts = afterGroupBase.split("[/\\\\]")

      // Extract group key from directory structure (e.g. "prague_eip7702_set_code_tx")
      def groupKey = extractGroupKey(parts)

      if (!groups.containsKey(groupKey)) {
        groups[groupKey] = []
      }
      groups[groupKey] << relativePath
    }
  }

  // Generate test files for each group, batched in groups of 5
  groups.each { groupKey, paths ->
    paths.collate(5).eachWithIndex { tests, idx ->
      def className = namePrefix + "_" + groupKey + "_" + idx
      def testFile = file(destination + "/" + className + ".java")
      def allPaths = '"' + tests.join('",\n        "') + '"'
      def testFileContents = referenceTestTemplate
        .replaceAll("%%TESTS_FILE%%", allPaths)
        .replaceAll("%%TESTS_NAME%%", className)
        .replaceAll("%%PACKAGE_NAME%%", packageString)
      testFile.newWriter().withWriter { w -> w << testFileContents }
    }
  }
}

// Extract a group key from path segments for hardfork/EIP-based test grouping.
// parts = path segments after groupBaseDir, e.g. ["prague", "eip7702_set_code_tx", "test.json"]
def extractGroupKey(String[] parts) {
  def groupKey
  if (parts.length >= 3 && parts[0] == "static") {
    // static dirs have deeper nesting: static/state_tests/stCreate2/file.json → static_stCreate2
    groupKey = "static_" + parts[parts.length - 2]
  } else if (parts.length >= 3) {
    // Normal: hardfork/eip/file.json → hardfork_eip
    groupKey = parts[0] + "_" + parts[1]
  } else if (parts.length == 2) {
    // File directly under hardfork dir: hardfork/file.json → hardfork
    groupKey = parts[0]
  } else {
    groupKey = "unknown"
  }
  return groupKey.replaceAll("[^a-zA-Z0-9_]", "_")
}
